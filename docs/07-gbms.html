<!DOCTYPE html>
<html>
  <head>
    <title>Gradient Boosting Machines</title>
    <meta charset="utf-8">
    <meta name="author" content="Brad Boehmke" />
    <meta name="date" content="2019-03-01" />
    <link href="libs/font-awesome-animation/font-awesome-animation-emi.css" rel="stylesheet" />
    <script src="libs/fontawesome/js/fontawesome-all.min.js"></script>
    <link href="libs/academicons/css/academicons.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="scrollable.css" type="text/css" />
    <link rel="stylesheet" href="mtheme_max.css" type="text/css" />
    <link rel="stylesheet" href="fonts_mtheme_max.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: clear, center, middle

background-image: url(images/gbm-icon.jpg)
background-position: center
background-size: cover

&lt;br&gt;&lt;br&gt;&lt;br&gt;
.font300.white[Gradient Boosting Machines]

---
# Introduction

.pull-left[

.center.bold.font120[Thoughts]

- Extremely popular

- One of the leading methods in prediction competitions

- Boosted trees <span>&lt;i class="fas  fa-arrow-right faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span> similar to, but quite different than, RFs <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="images/headpound_bunny.gif" style="height:1.5em; width:auto; "/&gt;</span>

- Math isn't that complicated until you want to generalize to all loss functions

]

--

.pull-right[

.center.bold.font120[Overview]

- Fundamental differences between RFs and GBMs

- Basic GBM

- Stochastic GBM

- XGBoost

]

---
# Prereqs .red[<span>&lt;i class="fas  fa-hand-point-right faa-horizontal animated " style=" color:red;"&gt;&lt;/i&gt;</span> code chunk 1]

.pull-left[

.center.bold.font120[Packages]


```r
library(gbm)
library(xgboost)
```


]

.pull-right[

.center.bold.font120[Data]


```r
# ames data
ames &lt;- AmesHousing::make_ames()

# split data
set.seed(123)
split &lt;- rsample::initial_split(ames, strata = "Sale_Price")
ames_train &lt;- rsample::training(split)
```

]

---
class: center, middle, inverse

.font300.white[Technicalities]

---
# Decision Trees

.pull-left[

* Many benefits <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1471045870/910/rock.gif?1471045870" style="height:1em; width:auto; "/&gt;</span>
   - .green[minimal preprocessing]
   - .green[can handle any data type]
   - .green[automatically captures interactions]
   - .green[scales well to large data]
   - .green[(can be) easy to interpret]
   
* A few significant weaknesses <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1471045885/967/wtf.gif?1471045885" style="height:1em; width:auto; "/&gt;</span>   
   - .red[large trees hard to interpret]
   - .red[trees are step functions] (i.e., binary splits)
   - .red[single trees typically have poor predictive accuracy]
   - .red[single trees have high variance] (easy to overfit to training data)

]

.pull-right[

&lt;img src="07-gbms_files/figure-html/dt-deep-1.png" style="display: block; margin: auto;" /&gt;

]

---
# Bagging

.pull-left[

* Benefits <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1471045870/910/rock.gif?1471045870" style="height:1em; width:auto; "/&gt;</span>
   - .green[takes advantage of a deep, single tree's high variance]
   - .green[wisdom of the crowd reduces prediction error]
   - .green[fast (typically only requires 50-100 trees)]

* Weaknesses <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1471045885/967/wtf.gif?1471045885" style="height:1em; width:auto; "/&gt;</span>  
   - .red[tree correlation]
   - .red[minimizes tree diversity and, therefore,]
   - .red[limited prediction error improvement ]

]

.pull-right[

&lt;img src="07-gbms_files/figure-html/bagging-gif-1.gif" style="display: block; margin: auto;" /&gt;

]

---
# Random Forests

.pull-left[

* Many benefits <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1471045870/910/rock.gif?1471045870" style="height:1em; width:auto; "/&gt;</span>
   - .green[all the benefits of individual trees and bagging plus...]
   - .green[split-variable randomization reduces tree correlation]
   - .green[typically results in reduced prediction error compared to bagging]
   - .green[good out-of-box performance]
   
* Weaknesses <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1471045885/967/wtf.gif?1471045885" style="height:1em; width:auto; "/&gt;</span> 
   - .red[Although accurate, often cannot compete with the accuracy of advanced boosting algorithms.]
   - .red[Can become slow on large data sets.]

]

.pull-right[

&lt;img src="07-gbms_files/figure-html/bagging-vs-random-forest-1.gif" style="display: block; margin: auto;" /&gt;

]

---
# How boosting works

.pull-left[

The main idea of boosting is to add new models to the ensemble sequentially. At each particular iteration, a new weak, base-learner model is trained with respect to the error of the whole ensemble learnt so far.

&lt;img src="images/boosted-trees-process.png" width="663" style="display: block; margin: auto;" /&gt;


]

--

.pull-right[

&lt;img src="https://media.giphy.com/media/3o84UeTqecxpcQJGOA/giphy.gif" style="display: block; margin: auto;" /&gt;


]

---
# How boosting works

.pull-left[

The main idea of boosting is to add new models to the ensemble sequentially. At each particular iteration, a new .blue.bold[weak], base-learner model is trained with respect to the error of the whole ensemble learnt so far.

&lt;img src="images/boosted-trees-process.png" width="663" style="display: block; margin: auto;" /&gt;

]

.pull-right[

A weak model:

* one whose error rate is only slightly better than random guessing

* each step slightly improves the remaining errors

* commonly, trees with only 1-6 splits are used

* Benefits of weak models
   - speed
   - accuracy improvement
   - can avoid overfitting

]

---
# How boosting works

.pull-left[

The main idea of boosting is to add new models to the ensemble sequentially. At each particular iteration, a new weak, .blue.bold[base-learner model] is trained with respect to the error of the whole ensemble learnt so far.

&lt;img src="images/boosted-trees-process.png" width="663" style="display: block; margin: auto;" /&gt;

]

.pull-right[

Base-learning models:

* boosting is a framework that iteratively improves any weak learning model

* many gradient boosting applications allow you to “plug in” various classes of weak learners at your disposal

* in practice however, boosted algorithms almost always use decision trees as the base-learner

]

---
# How boosting works

.pull-left[

The main idea of boosting is to add new models to the ensemble sequentially. At each particular iteration, a new weak, base-learner model is .blue.bold[trained with respect to the error] of the whole ensemble learnt so far.

&lt;img src="images/boosted-trees-process.png" width="663" style="display: block; margin: auto;" /&gt;

]

.pull-right[

Sequential training with respect to errors:

* boosted trees are grown sequentially; each tree is grown using information from previously grown trees. 

   1. Fit a decision tree to the data: `\(F_1(x) = y\)`,
   2. We then fit the next decision tree to the residuals of the previous: `\(h_1(x) = y - F_1(x)\)`,
   3. Add this new tree to our algorithm: `\(F_2(x) = F_1(x) + h_1(x)\)`,
   4. Fit the next decision tree to the residuals of `\(F_2\)`: `\(h_2(x) = y - F_2(x)\)`,
   5. Add this new tree to our algorithm: `\(F_3(x) = F_2(x) + h_1(x)\)`,
   6. Continue this process until some mechanism (i.e. cross validation) tells us to stop.

]

---
# How boosting works

We call this sequential training .blue.bold[additive model ensembling] where each iteration gradually nudges our predicted values closer to the target.

.pull-left[

$$
`\begin{aligned}
 \hat y &amp; = f_0(x) + \triangle_1(x) + \triangle_2(x) + \cdots + \triangle_M(x)  \\
        &amp; = f_0(x) + \sum^M_{m=1} \triangle_m(x) \\
        &amp; = F_m(x)
\end{aligned}`
$$

Also written as...

$$
`\begin{aligned}
 F_0(x) &amp; = f_0(x) \\
 F_m(x) &amp; = F_{m-1}(x) + \triangle_m(x)
\end{aligned}`
$$

]

.pull-right[

&lt;img src="images/golf-dir-vector.png" width="2888" style="display: block; margin: auto;" /&gt;

.font60.right[Image: [Terence Parr &amp; Jeremy Howard](https://explained.ai/gradient-boosting/L2-loss.html)]

]

---
# How boosting works

.pull-left[

&lt;img src="07-gbms_files/figure-html/gbm-illustration-1.gif" style="display: block; margin: auto;" /&gt;

]

.pull-right[

&lt;img src="07-gbms_files/figure-html/gbm-residual-illustration-1.gif" style="display: block; margin: auto;" /&gt;

]

---
# Boosting &gt; Random Forest &gt; Bagging &gt; Single Tree

.pull-left[

&lt;br&gt;&lt;br&gt;

.center.font120.blue[Typically, this allows us to eek out additional predictive performance!]

]

.pull-right[
&lt;img src="07-gbms_files/figure-html/bagging-vs-random-forest-vs-boosting-1.gif" style="display: block; margin: auto;" /&gt;
]

---
class: center, middle, inverse

.font300.white[Basic GBM]

---
# Basic GBM

.pull-left[

.bold.font110[[gbm](https://github.com/gbm-developers/gbm)]
- The original R implementation of GMBs (by Greg Ridgeway)
- Slower than modern implementations (but still pretty fast)
- Provides OOB error estimate
- Supports the weighted tree traversal method for fast construction of PDPs

   
.bold.font110[[gbm3](https://github.com/gbm-developers/gbm3)]
- Shiny new version of gbm that is not backwards compatible
- Faster and supports parallel tree building
- Not currently listed on CRAN

]

.pull-right[

&lt;img src="images/gbm-developers.png" width="1327" style="display: block; margin: auto;" /&gt;

.center.bold.red[Great looking support team <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1542340460/4963/blush.gif" style="height:2em; width:auto; "/&gt;</span>]

]

---
# Basic GBM .red[<span>&lt;i class="fas  fa-hand-point-right faa-horizontal animated " style=" color:red;"&gt;&lt;/i&gt;</span> code chunk 2]

.pull-left[

.bold.font110[[gbm](https://github.com/gbm-developers/gbm)]
- The original R implementation of GMBs (by Greg Ridgeway)
- Slower than modern implementations (but still pretty fast)
- Provides OOB error estimate
- Supports the weighted tree traversal method for fast construction of PDPs

.opacity20[   
.bold.font110[[gbm3](https://github.com/gbm-developers/gbm3)]
- Shiny new version of gbm that is not backwards compatible
- Faster and supports parallel tree building
- Not currently listed on CRAN
]
]

.pull-right[
.center.bold.font90[Let's run your first GBM model]


```r
set.seed(123)
ames_gbm &lt;- gbm(
  formula = Sale_Price ~ .,
  data = ames_train,
  distribution = "gaussian", # or bernoulli, multinomial, etc. 
  n.trees = 5000, 
  shrinkage = 0.1, 
  interaction.depth = 1, 
  n.minobsinnode = 10, 
  cv.folds = 5 
  )  

# find index for n trees with minimum CV error
min_MSE &lt;- which.min(ames_gbm$cv.error)

# get MSE and compute RMSE
sqrt(ames_gbm$cv.error[min_MSE])
## [1] 27028.1
```

.center.bold.font90[<span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>  This grid search takes ~30 secs <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>]

]

---
# What's going on?


.pull-left.font90[

&lt;br&gt;

* .bold[`distribution`]: specify distribution of response variable; `gbm` will make intelligent guess

* .bold[`n.trees`]: number of sequential trees to fit

* .bold[`shrinkage`]: how quickly do we improve on each iteration (aka _learning rate_)

* .bold[`interaction.depth`]: how weak of a learner do we want

* .bold[`n.minobsinnode`]: minimum number of observations in the trees terminal nodes

* .bold[`cv.folds`]: _k_-fold cross validation

]

.pull-right[

.opacity20.center.bold.font90[Let's run your first GBM model]


```r
set.seed(123)
ames_gbm &lt;- gbm(
  formula = Sale_Price ~ .,
  data = ames_train,
* distribution = "gaussian", # or bernoulli, multinomial, etc.
* n.trees = 5000,
* shrinkage = 0.1,
* interaction.depth = 1,
* n.minobsinnode = 10,
* cv.folds = 5
  )  

# find index for n trees with minimum CV error
min_MSE &lt;- which.min(ames_gbm$cv.error)

# get MSE and compute RMSE
sqrt(ames_gbm$cv.error[min_MSE])
## [1] 27028.1
```

.opacity20.center.bold.font90[<span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>  This grid search takes ~30 secs <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>]

]

---
# What's going on?


.pull-left.font90[

.bold.center[Tunable Hyperparameters]

* .opacity20[`distribution`: specify distribution of response variable; `gbm` will make intelligent guess]

* .bold[`n.trees`]: number of sequential trees to fit

* .bold[`shrinkage`]: how quickly do we improve on each iteration (aka _learning rate_)

* .bold[`interaction.depth`]: how weak of a learner do we want

* .bold[`n.minobsinnode`]: minimum number of observations in the trees terminal nodes

* .opacity20[`cv.folds`: _k_-fold cross validation]

]

.pull-right[

.opacity20.center.bold.font90[Let's run your first GBM model]


```r
set.seed(123)
ames_gbm &lt;- gbm(
  formula = Sale_Price ~ .,
  data = ames_train,
* distribution = "gaussian", # or bernoulli, multinomial, etc.
* n.trees = 5000,
* shrinkage = 0.1,
* interaction.depth = 1,
* n.minobsinnode = 10,
* cv.folds = 5
  )  

# find index for n trees with minimum CV error
min_MSE &lt;- which.min(ames_gbm$cv.error)

# get MSE and compute RMSE
sqrt(ames_gbm$cv.error[min_MSE])
## [1] 27028.1
```

.opacity20.center.bold.font90[<span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>  This grid search takes ~30 secs <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>]

]

---
# Tuning <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

In contrast to Random Forests, GBMs .bold.red[do not] provide good "out-of-the-<span>&lt;i class="fas  fa-box-open faa-pulse animated-hover "&gt;&lt;/i&gt;</span>" performance!

--

We can divide hyperparameters into 2 primary categories:

--

.pull-left[

.center.bold[Boosting Parameters]

- Number of trees

- Learning rate

- More to come!

]

.pull-right[

.center.bold[Tree-specific Parameters]

- Tree depth

- Minimum obs in terminal node

- And others

]

---
# Boosting hyperparameters <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

.pull-left[

.blue.bold[Number of trees]

- The averaging in bagging and RF makes it very difficult to overfit with too many trees

- GBMs will chase residuals as long as you allow them to

- Consequently:
   - We must provide enough trees to minimize error
   - But not too many where we begin to overfit


]

.pull-right[

&lt;img src="07-gbms_files/figure-html/num-trees-1.gif" style="display: block; margin: auto;" /&gt;

]

---
# Boosting hyperparameters <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>  .red[<span>&lt;i class="fas  fa-hand-point-right faa-horizontal animated " style=" color:red;"&gt;&lt;/i&gt;</span> code chunk 3]

.pull-left[

.blue.bold[Number of trees]

- The averaging in bagging and RF makes it very difficult to overfit with too many trees

- GBMs will chase residuals as long as you allow them to

- Consequently:
   - We must provide enough trees to minimize error
   - But not too many where we begin to overfit
   - .red[plus, number of trees is dependent on other hyperparameters]

.center.bold.blue[Use CV or OOB] 

]

.pull-right[


```r
gbm.perf(ames_gbm, method = "cv") # or "OOB"
```

&lt;img src="07-gbms_files/figure-html/unnamed-chunk-1-1.png" style="display: block; margin: auto;" /&gt;

```
## [1] 1387
```

&lt;br&gt;   
.center.bold.blue[Use CV or OOB]   

]

---
# Boosting hyperparameters <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

.pull-left[

.blue.bold[Learning rate] (aka shrinkage)

.font120[
- Determines the impact of each tree on the final outcome
]

]

.pull-right[

&lt;img src="07-gbms_files/figure-html/learning-rate-1.png" style="display: block; margin: auto;" /&gt;

]

---
# Boosting hyperparameters <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

.pull-left[

.blue.bold[Learning rate] (aka shrinkage)

- Determines the impact of each tree on the final outcome

- .red[Too large of a learning rate will have poor predictive capability]

- Lower values are generally preferred:
   - .green[they make the model robust to the specific characteristics of tree and thus allowing it to generalize well]
   - .green[easier to stop prior to overfitting]
   - .red[but run the risk of not reaching the optimum]
   - .red[are more computationally demanding]

]

.pull-right[

&lt;img src="07-gbms_files/figure-html/learning-rate-too-big-1.png" style="display: block; margin: auto;" /&gt;

]

---
# Boosting hyperparameters <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

.pull-left[

.blue.bold[Learning rate] (aka shrinkage)

- Determines the impact of each tree on the final outcome

- .red[Too large of a learning rate will have poor predictive capability]

- Lower values are generally preferred (.01 - .1):
   - .green[they make the model robust to the specific characteristics of tree and thus allowing it to generalize well]
   - .green[easier to stop prior to overfitting]
   - .red[but run the risk of not reaching the optimum]
   - .red[are more computationally demanding]
   - .bold[Requires more trees!]

]

.pull-right[

&lt;img src="07-gbms_files/figure-html/small-rate-more-trees-1.gif" style="display: block; margin: auto;" /&gt;

]

---
# Tree-specific hyperparameters <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

.pull-left[

.blue.bold[Tree depth]

- controls over-fitting
- higher depth captures unique interactions
- but runs risk of over-fitting
- smaller depth (i.e. stumps) are computationally efficient (but .bold[require more trees!])
- typical values: 3-8
   - larger _n_ or _p_ are more tolerable to <span>&lt;i class="fas  fa-arrow-up faa-FALSE animated "&gt;&lt;/i&gt;</span> values


.blue.bold[Min obs in terminal nodes]

- controls over-fitting
- higher values prevent a model from learning relations which might be highly specific to the particular sample selected for a tree
- typically have small impact on performance
- smaller values can help with imbalanced classes 

]

.pull-right[

&lt;img src="07-gbms_files/figure-html/depth-and-nodes-1.gif" style="display: block; margin: auto;" /&gt;

]


---
# Tuning strategy <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

&lt;br&gt;
.font120[
1. Choose a relatively high learning rate. Generally the default value of 0.1 works but somewhere between 0.05 to 0.2 should work for different problems

2. Determine the optimum number of trees for this learning rate. 

3. Tune learning rate and assess speed vs. performance

4. Tune tree-specific parameters for decided learning rate and number of trees. 

5. Lower the learning rate and increase the estimators proportionally to get more robust models.
]

---
# Tuning strategy <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>  .red[<span>&lt;i class="fas  fa-hand-point-right faa-horizontal animated " style=" color:red;"&gt;&lt;/i&gt;</span> code chunk 4]

.scrollable90[
.pull-left[
&lt;br&gt;
.font110[
1. fix tree hyperparameters
    - moderate tree depth
    - default min obs
2. set our learning rate at .01
3. increase CV to ensure unbiased error estimate
4. Results
   - Lowest error rate yet ($21,914.55)!
   - Used nearly all our trees `\(\rightarrow\)` increase to 6000?
   - took `\(\approx\)` 2.25 min
5. Compared to learning rate of .001
   - error rate of $24,791.66
   - took `\(\approx\)` 4 min
]
]

.pull-right[

.center.bold.font90[<span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>  This model run takes ~2 mins <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>]


```r
set.seed(123)
ames_gbm1 &lt;- gbm(
  formula = Sale_Price ~ .,
  data = ames_train,
* distribution = "gaussian", # or bernoulli, multinomial, etc.
* n.trees = 5000,
* shrinkage = 0.01,
* interaction.depth = 3,
* n.minobsinnode = 10,
* cv.folds = 10
  )

# find index for n trees with minimum CV error
min_MSE &lt;- which.min(ames_gbm1$cv.error)

# get MSE and compute RMSE
sqrt(ames_gbm1$cv.error[min_MSE])
## [1] 21914.55

gbm.perf(ames_gbm1, method = "cv")
```

&lt;img src="07-gbms_files/figure-html/tune1-1.png" style="display: block; margin: auto;" /&gt;

```
## [1] 4999
```

]
]

---
# Tuning strategy <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>  .red[<span>&lt;i class="fas  fa-hand-point-right faa-horizontal animated " style=" color:red;"&gt;&lt;/i&gt;</span> code chunk 5]

.scrollable90[
.pull-left[

Now let's tune the tree-specific hyperparameters

* we could do it in `caret` but lets use functional programming

&lt;img src="images/hell-yeah.png" width="25%" height="25%" style="display: block; margin: auto;" /&gt;

* assess 3 values for tree depth

* assess 3 values for min obs in terminal node

]

.pull-right[
.center[<span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span> <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span> <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>]
.center.font90.bold[This grid search takes ~30 mins; remember, I said the ML process is more of a marathon than a sprint!!]
.center[<span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span> <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span> <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>]



```r
# search grid
hyper_grid &lt;- expand.grid(
  n.trees = 6000,
  shrinkage = .01,
* interaction.depth = c(3, 5, 7),
* n.minobsinnode = c(5, 10, 15)
)

model_fit &lt;- function(n.trees, shrinkage, interaction.depth, n.minobsinnode) {
  set.seed(123)
  m &lt;- gbm(
    formula = Sale_Price ~ .,
    data = ames_train,
    distribution = "gaussian",
    n.trees = n.trees,
*   shrinkage = shrinkage,
*   interaction.depth = interaction.depth,
    n.minobsinnode = n.minobsinnode,
    cv.folds = 10
  )
  # compute RMSE
  sqrt(min(m$cv.error))
}

hyper_grid$rmse &lt;- pmap_dbl(
  hyper_grid,
  ~ model_fit(
    n.trees = ..1,
    shrinkage = ..2,
    interaction.depth = ..3,
    n.minobsinnode = ..4
    )
)

arrange(hyper_grid, rmse)
##   n.trees shrinkage interaction.depth n.minobsinnode     rmse
## 1    6000      0.01                 7              5 20683.65
## 2    6000      0.01                 5              5 20746.36
## 3    6000      0.01                 7             10 21114.62
## 4    6000      0.01                 3              5 21126.33
## 5    6000      0.01                 5             10 21228.68
## 6    6000      0.01                 7             15 21246.73
## 7    6000      0.01                 5             15 21272.91
## 8    6000      0.01                 3             10 21767.08
## 9    6000      0.01                 3             15 21862.35
```

]]

---
class: center, middle, inverse

.font300.white[Stochastic GBM]


---
# Adding randomness

&lt;br&gt;

- Friedman (1999) [<span>&lt;i class="ai  ai-google-scholar faa-tada animated-hover "&gt;&lt;/i&gt;</span>](https://statweb.stanford.edu/~jhf/ftp/stobst.pdf) introduced stochastic gradient boosting

- A big insight into bagging ensembles and random forest was allowing trees to be created from random subsamples of the training dataset <span>&lt;i class="fas  fa-arrow-right faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span> minimizes tree correlation among sequential trees

- Improves computational time since we're reducing *n*

- A few variants of stochastic boosting that can be used:
   - Subsample rows before creating each tree (__gbm__)
   - Subsample columns before creating each tree (__h2o__ &amp; __xgboost__)
   - Subsample columns before considering each split (__h2o__ &amp; __xgboost__)

- .blue.bold[Pro tip]: Generally, aggressive sub-sampling such as selecting only 50% of the data has shown to be beneficial. Typical values: 0.5-0.8

---
# Applying

.pull-left[

- start by assessing if values between 0.5-0.8 outperform your previous best model

- zoom in with a second round of tuning

- smaller values will tell you that overfitting was occurring

]

.pull-right[


```r
*bag_frac &lt;- c(.5, .65, .8)

for(i in bag_frac) {
  set.seed(123)
  m &lt;- gbm(
    formula = Sale_Price ~ .,
    data = ames_train,
    distribution = "gaussian",
    n.trees = 6000, 
    shrinkage = 0.01, 
    interaction.depth = 7, 
    n.minobsinnode = 5,
*   bag.fraction = i,
    cv.folds = 10 
    )
  # compute RMSE
  print(sqrt(min(m$cv.error)))
}
## [1] 20683.65
## [1] 20398.93
## [1] 20287.76
```

]

---
class: center, middle, inverse

.font300.white[Extreme Gradient Boosting]

---
# XGBoost Advantage

&lt;br&gt;
Extreme Gradient boosting (XGBoost) provides a few advantages over traditional boosting:

- .bold[Regularization]: Standard GBM implementation has no regularization like XGBoost; helps to reduce overfitting.

- .bold[Parallel Processing]: GPU and Spark compatible 

- .bold[Loss functions]: allows users to define custom optimization objectives and evaluation criteria

- .bold[Tree pruning]: splits up to the max depth specified and then pruning; uses the weakest learner required

- .bold[Continue existing model]: User can start training an XGBoost model from its last iteration of previous run 

.center.bold.blue[Super powerful...super <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1471045885/967/wtf.gif?1471045885" style="height:1em; width:auto; "/&gt;</span> awesome!]

---
# Prereqs

.pull-left[

* __xgboost__ requires that our features are one-hot encoded

* __caret__ and __h2o::h2o.xgboost__ can automate this for you

]

.pull-right[


```r
library(recipes)
xgb_prep &lt;- recipe(Sale_Price ~ ., ames_train) %&gt;%
  step_dummy(all_nominal(), one_hot = TRUE) %&gt;%
  prep(training = ames_train, retain = TRUE) %&gt;%
  juice()

X &lt;- as.matrix(xgb_prep[setdiff(names(xgb_prep), "Sale_Price")])
Y &lt;- xgb_prep$Sale_Price
```

]

---
# First XGBoost model

.pull-left.font90[

&lt;br&gt;

* .bold[`nrounds`]: 6,000 trees 

* .bold[`objective`]: `reg:linear` for regression but other options exist (i.e. `reg:logistic`, `binary:logistic`, `num_class`)

* .bold[`early_stopping_rounds`]: stop training if CV RMSE doesn't improve for 50 trees in a row 

* .bold[`nfold`]: 10-fold CV 

&lt;br&gt;

.center.bold[What's up with the results <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1542340469/4974/notinterested.gif" style="height:2.5em; width:auto; "/&gt;</span>!!!]

]

.pull-right[

.center.bold.font90[<span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>  This grid search takes ~1 min <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>]


```r
set.seed(123)
ames_xgb &lt;- xgb.cv(
  data = X,
  label = Y,
  nrounds = 6000,
  objective = "reg:linear",
  early_stopping_rounds = 50, 
  nfold = 10,
  verbose = 0,
  )  

ames_xgb$evaluation_log %&gt;% tail()
##    iter train_rmse_mean train_rmse_std test_rmse_mean test_rmse_std
## 1:  244        475.6274       56.41166       23973.07      2590.963
## 2:  245        470.9972       57.11887       23973.70      2590.520
## 3:  246        463.2655       57.94811       23973.26      2590.541
## 4:  247        458.2460       58.34277       23973.23      2590.775
## 5:  248        451.8473       58.35864       23973.05      2590.151
## 6:  249        445.7978       57.72149       23972.80      2591.660
```

]

---
# Tuning <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

&lt;br&gt;
.pull-left.font110[
1. Crank up the trees and tune learning rate with early stopping
   - initial test RMSE results:
   - `eta = .3` (default): 23,972 w/249 trees (1 min)
   - `eta = .1`: 22,567 w/498 trees (2.75 min)
   - `eta = .01`: 22,591 w/3146 trees (18 min)

]

.pull-right[


```r
set.seed(123)
ames_xgb &lt;- xgb.cv(
  data = X,
  label = Y,
  nrounds = 6000,
  objective = "reg:linear",
  early_stopping_rounds = 50, 
  nfold = 10,
  verbose = 0,
* params = list(eta = .1)
  )  

ames_xgb$evaluation_log %&gt;% tail()
##    iter train_rmse_mean train_rmse_std test_rmse_mean test_rmse_std
## 1:  493        1426.474       62.82684       22565.68      2065.301
## 2:  494        1422.654       62.65673       22566.34      2063.881
## 3:  495        1415.531       60.27212       22566.58      2063.937
## 4:  496        1410.478       61.11700       22566.61      2063.776
## 5:  497        1406.350       61.90959       22566.90      2063.995
## 6:  498        1400.308       61.81945       22567.10      2062.610
```
]

---
# Tuning <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

.scrollable90[
.pull-left.font110[
&lt;br&gt;
1. .opacity[Crank up the trees and tune learning rate with early stopping]
2. Tune tree-specific hyperparameters
   - tree depth
   - instances required to make additional split

]

.pull-right[

.center.bold.font90[<span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>  This grid search takes ~30 min <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>]


```r
# grid
hyper_grid &lt;- expand.grid(
  eta = .1,
* max_depth = c(5, 7, 9),
* min_child_weight = c(5, 10, 15),
  rmse = 0 # a place to dump results
  )

# grid search
for(i in seq_len(nrow(hyper_grid))) {
  set.seed(123)
  m &lt;- xgb.cv(
    data = X,
    label = Y,
    nrounds = 6000,
    objective = "reg:linear",
    early_stopping_rounds = 50, 
    nfold = 10,
    verbose = 0,
*   params = list(
*     eta = hyper_grid$eta[i],
*     max_depth = hyper_grid$max_depth[i],
*     min_child_weight = hyper_grid$min_child_weight[i]
*   )
  )
  hyper_grid$rmse[i] &lt;- min(m$evaluation_log$test_rmse_mean)
}

arrange(hyper_grid, rmse)
##   eta max_depth min_child_weight     rmse
## 1 0.1         5                5 21995.84
## 2 0.1         9                5 22375.97
## 3 0.1         7                5 22556.79
## 4 0.1         7               10 22786.54
## 5 0.1         5               10 22983.33
## 6 0.1         5               15 23099.17
## 7 0.1         7               15 23697.61
## 8 0.1         9               10 23767.89
## 9 0.1         9               15 23943.83
```

]
]

---
# Tuning <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

.scrollable90[
.pull-left.font110[
&lt;br&gt;
1. .opacity[Crank up the trees and tune learning rate with early stopping]
2. .opacity[Tune tree-specific hyperparameters]
3. Add stochastic attributes with
   - subsampling rows for each tree
   - subsampling columns for each tree 

]

.pull-right[

.center.bold.font90[<span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>  This grid search takes ~30 min <span>&lt;i class="fas  fa-exclamation-triangle faa-FALSE animated " style=" color:red;"&gt;&lt;/i&gt;</span>]


```r
# grid
hyper_grid &lt;- expand.grid(
  eta = .1,
* subsample = c(.5, .65, .8, 1),
* colsample_bytree = c(.5, .65, .8, 1),
  rmse = 0 # a place to dump results
  )

# grid search
for(i in seq_len(nrow(hyper_grid))) {
  set.seed(123)
  m &lt;- xgb.cv(
    data = X,
    label = Y,
    nrounds = 6000,
    objective = "reg:linear",
    early_stopping_rounds = 50, 
    nfold = 10,
    verbose = 0,
*   params = list(
*     eta = hyper_grid$eta[i],
*     subsample = hyper_grid$subsample[i],
*     colsample_bytree = hyper_grid$colsample_bytree[i]
*   )
  )
  hyper_grid$rmse[i] &lt;- min(m$evaluation_log$test_rmse_mean)
}

arrange(hyper_grid, rmse)
##    eta subsample colsample_bytree     rmse
## 1  0.1      0.65             1.00 22135.71
## 2  0.1      0.80             1.00 22482.75
## 3  0.1      0.65             0.80 22492.82
## 4  0.1      1.00             1.00 22558.62
## 5  0.1      0.80             0.80 22667.84
## 6  0.1      0.50             1.00 22782.88
## 7  0.1      0.65             0.65 22785.15
## 8  0.1      1.00             0.80 22965.59
## 9  0.1      0.80             0.65 23213.12
## 10 0.1      0.65             0.50 23258.04
## 11 0.1      0.50             0.50 23278.92
## 12 0.1      1.00             0.65 23312.92
## 13 0.1      0.50             0.80 23482.31
## 14 0.1      0.50             0.65 23918.63
## 15 0.1      0.80             0.50 24105.32
## 16 0.1      1.00             0.50 24110.25
```

]
]

---
# Tuning <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

.scrollable90[
.pull-left.font110[
&lt;br&gt;
1. .opacity[Crank up the trees and tune learning rate with early stopping]
2. .opacity[Tune tree-specific hyperparameters]
3. .opacity[Add stochastic attributes with]
4. See if adding regularization helps
   - gamma: tested 0.001, 0.01, 0.1, 1, 100, 1000 -- no effect
   - lambda: tested 0.001, 0.01, 0.1, 1, 100, 1000 -- no effect
   - alpha: tested 0.001, 0.01, 0.1, 1, 100, 1000 -- minimal effect

]

.pull-right[


```r
hyper_grid &lt;- expand.grid(
  eta = .1,
  #gamma = c(1e-2, 0.1, 1, 100, 1000),
  #lambda = c(1e-2, 0.1, 1, 100, 1000),
* alpha = c(1e-2, 0.1, 1, 100, 1000),
  rmse = 0 # a place to dump results
  )

# grid search
for(i in seq_len(nrow(hyper_grid))) {
  set.seed(123)
  m &lt;- xgb.cv(
    data = X,
    label = Y,
    nrounds = 6000,
    objective = "reg:linear",
    early_stopping_rounds = 50, 
    nfold = 10,
    verbose = 0,
*   params = list(
*     eta = hyper_grid$eta[i],
*     #gamma = hyper_grid$gamma[i],
*     #lambda = hyper_grid$lambda[i],
      alpha = hyper_grid$alpha[i]
*   )
  )
  hyper_grid$rmse[i] &lt;- min(m$evaluation_log$test_rmse_mean)
}

arrange(hyper_grid, rmse)
##   eta alpha     rmse
## 1 0.1 1e+02 22536.92
## 2 0.1 1e-01 22567.20
## 3 0.1 1e+00 22572.61
## 4 0.1 1e-02 22572.94
## 5 0.1 1e+03 22668.12
```

]]

---
# Tuning <span>&lt;i class="fas  fa-cog faa-spin animated faa-slow " style=" color:red;"&gt;&lt;/i&gt;</span>

&lt;br&gt;
.pull-left.font110[
1. .opacity[Crank up the trees and tune learning rate with early stopping]
2. .opacity[Tune tree-specific hyperparameters]
3. .opacity[Add stochastic attributes with]
4. .opacity[See if adding regularization helps]
5. Rerun final "optimal" model

]

---
class: center, middle, inverse

.font300.white[Feature Interpretation]

---
# Feature Importance


---
# Feature Effects


---
class: center, middle, inverse

.font300.white[Wrapping Up]

---

# Learning More

.pull-left[

&lt;img src="images/isl.jpg" width="55%" height="55%" style="display: block; margin: auto;" /&gt;

.center.font150[[Book website](http://www-bcf.usc.edu/~gareth/ISL/)]
]


.pull-right[

&lt;img src="images/esl.jpg" width="55%" height="55%" style="display: block; margin: auto;" /&gt;

.center.font150[[Book website](https://web.stanford.edu/~hastie/ElemStatLearn/)]
]

---

# Other Great Resources

&lt;br&gt;
.font120[

* [How to explain gradient boosting](https://explained.ai/gradient-boosting/)

* [A Gentle Introduction to the Gradient Boosting Algorithm for Machine Learning](https://machinelearningmastery.com/gentle-introduction-gradient-boosting-algorithm-machine-learning/)

* [Complete Guide to Parameter Tuning in Gradient Boosting (GBM)](https://www.analyticsvidhya.com/blog/2016/02/complete-guide-parameter-tuning-gradient-boosting-gbm-python/)

* [Complete Guide to Parameter Tuning in XGBoost](https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/)

]


---
class: clear, center, middle

background-image: url(http://www.ibnjuferi.us/wp-content/uploads/ask_google.gif)
background-size: contain

---
# Back home

&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
[.center[<span>&lt;i class="fas  fa-home fa-10x faa-FALSE animated "&gt;&lt;/i&gt;</span>]](https://github.com/uc-r/Advanced-R)

.center[https://github.com/uc-r/Advanced-R]
    </textarea>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
